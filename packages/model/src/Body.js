// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Decco = require("decco/src/Decco.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Js_json = require("bs-platform/lib/js/js_json.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Format$LiteralModel = require("./Format.js");
var Language$LiteralModel = require("./Language.js");
var Motivation$LiteralModel = require("./Motivation.js");
var TextDirection$LiteralModel = require("./TextDirection.js");

function textualBody_encode(v) {
  return Js_dict.fromArray([
              [
                "id",
                Decco.stringToJson(v.id)
              ],
              [
                "format",
                Decco.optionToJson(Decco.stringToJson, v.format)
              ],
              [
                "language",
                Decco.optionToJson(Decco.stringToJson, v.language)
              ],
              [
                "processingLanguage",
                Decco.optionToJson(Decco.stringToJson, v.processingLanguage)
              ],
              [
                "textDirection",
                Decco.optionToJson(Decco.stringToJson, v.textDirection)
              ],
              [
                "purpose",
                Decco.optionToJson((function (param) {
                        return Decco.arrayToJson(Decco.stringToJson, param);
                      }), v.purpose)
              ],
              [
                "accessibility",
                Decco.optionToJson((function (param) {
                        return Decco.arrayToJson(Decco.stringToJson, param);
                      }), v.accessibility)
              ],
              [
                "rights",
                Decco.optionToJson((function (param) {
                        return Decco.arrayToJson(Decco.stringToJson, param);
                      }), v.rights)
              ],
              [
                "value",
                Decco.stringToJson(v.value)
              ],
              [
                "type",
                Decco.stringToJson(v.type_)
              ],
              [
                "__typename",
                Decco.stringToJson(v.typename)
              ]
            ]);
}

function textualBody_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Decco.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Decco.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var id = Decco.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "id"), null));
  if (id.TAG) {
    var e = id._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".id" + e.path,
              message: e.message,
              value: e.value
            }
          };
  }
  var format = Decco.optionFromJson(Decco.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "format"), null));
  if (format.TAG) {
    var e$1 = format._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".format" + e$1.path,
              message: e$1.message,
              value: e$1.value
            }
          };
  }
  var language = Decco.optionFromJson(Decco.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "language"), null));
  if (language.TAG) {
    var e$2 = language._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".language" + e$2.path,
              message: e$2.message,
              value: e$2.value
            }
          };
  }
  var processingLanguage = Decco.optionFromJson(Decco.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "processingLanguage"), null));
  if (processingLanguage.TAG) {
    var e$3 = processingLanguage._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".processingLanguage" + e$3.path,
              message: e$3.message,
              value: e$3.value
            }
          };
  }
  var textDirection = Decco.optionFromJson(Decco.stringFromJson, Belt_Option.getWithDefault(Js_dict.get(dict$1, "textDirection"), null));
  if (textDirection.TAG) {
    var e$4 = textDirection._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".textDirection" + e$4.path,
              message: e$4.message,
              value: e$4.value
            }
          };
  }
  var purpose = Decco.optionFromJson((function (param) {
          return Decco.arrayFromJson(Decco.stringFromJson, param);
        }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "purpose"), null));
  if (purpose.TAG) {
    var e$5 = purpose._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".purpose" + e$5.path,
              message: e$5.message,
              value: e$5.value
            }
          };
  }
  var accessibility = Decco.optionFromJson((function (param) {
          return Decco.arrayFromJson(Decco.stringFromJson, param);
        }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "accessibility"), null));
  if (accessibility.TAG) {
    var e$6 = accessibility._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".accessibility" + e$6.path,
              message: e$6.message,
              value: e$6.value
            }
          };
  }
  var rights = Decco.optionFromJson((function (param) {
          return Decco.arrayFromJson(Decco.stringFromJson, param);
        }), Belt_Option.getWithDefault(Js_dict.get(dict$1, "rights"), null));
  if (rights.TAG) {
    var e$7 = rights._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".rights" + e$7.path,
              message: e$7.message,
              value: e$7.value
            }
          };
  }
  var value = Decco.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "value"), null));
  if (value.TAG) {
    var e$8 = value._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".value" + e$8.path,
              message: e$8.message,
              value: e$8.value
            }
          };
  }
  var type_ = Decco.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "type"), null));
  if (type_.TAG) {
    var e$9 = type_._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".type" + e$9.path,
              message: e$9.message,
              value: e$9.value
            }
          };
  }
  var typename = Belt_Option.getWithDefault(Belt_Option.map(Js_dict.get(dict$1, "__typename"), Decco.stringFromJson), {
        TAG: /* Ok */0,
        _0: "TextualBody"
      });
  if (!typename.TAG) {
    return {
            TAG: /* Ok */0,
            _0: {
              id: id._0,
              format: format._0,
              language: language._0,
              processingLanguage: processingLanguage._0,
              textDirection: textDirection._0,
              purpose: purpose._0,
              accessibility: accessibility._0,
              rights: rights._0,
              value: value._0,
              type_: type_._0,
              typename: typename._0
            }
          };
  }
  var e$10 = typename._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".__typename" + e$10.path,
            message: e$10.message,
            value: e$10.value
          }
        };
}

function makeTextualBody(value, id, format, language, processingLanguage, textDirection, purpose, accessibility, rights, param) {
  return {
          id: id,
          format: format,
          language: language,
          processingLanguage: processingLanguage,
          textDirection: textDirection,
          purpose: purpose,
          accessibility: accessibility,
          rights: rights,
          value: value,
          type_: "TEXTUAL_BODY",
          typename: "TextualBody"
        };
}

function makeTextualBodyFromGraphQL(textualBody) {
  return {
          TAG: /* TextualBody */0,
          _0: makeTextualBody(textualBody.value, textualBody.id, Belt_Option.map(textualBody.format, Format$LiteralModel.toString), Belt_Option.map(textualBody.language, Language$LiteralModel.toString), Belt_Option.map(textualBody.processingLanguage, Language$LiteralModel.toString), Belt_Option.map(textualBody.textDirection, TextDirection$LiteralModel.toString), Belt_Option.map(textualBody.purpose, (function (d) {
                      return Belt_Array.map(d, Motivation$LiteralModel.toString);
                    })), textualBody.accessibility, textualBody.rights, undefined)
        };
}

function decoder(json) {
  var match = Js_json.classify(json);
  if (typeof match === "number") {
    return {
            TAG: /* Error */1,
            _0: {
              path: "",
              message: "Expected JSONObject for body",
              value: json
            }
          };
  }
  if (match.TAG !== /* JSONObject */2) {
    return {
            TAG: /* Error */1,
            _0: {
              path: "",
              message: "Expected JSONObject for body",
              value: json
            }
          };
  }
  var textualBody = textualBody_decode(json);
  if (textualBody.TAG) {
    return {
            TAG: /* Ok */0,
            _0: {
              TAG: /* NotImplemented_Passthrough */1,
              _0: json
            }
          };
  } else {
    return {
            TAG: /* Ok */0,
            _0: {
              TAG: /* TextualBody */0,
              _0: textualBody._0
            }
          };
  }
}

function encoder(inst) {
  if (inst.TAG) {
    return inst._0;
  } else {
    return textualBody_encode(inst._0);
  }
}

var codec = [
  encoder,
  decoder
];

exports.textualBody_encode = textualBody_encode;
exports.textualBody_decode = textualBody_decode;
exports.makeTextualBody = makeTextualBody;
exports.makeTextualBodyFromGraphQL = makeTextualBodyFromGraphQL;
exports.decoder = decoder;
exports.encoder = encoder;
exports.codec = codec;
/* No side effect */
